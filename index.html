<!DOCTYPE html>
<html lang="cs">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vyhledávání písní</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #e8f5e8, #f0f8f0);
        min-height: 100vh;
        padding: 20px;
        line-height: 1.6;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 40px;
      }

      .header h1 {
        color: #2d5a2d;
        font-size: clamp(1.8rem, 4vw, 2.5rem);
        margin-bottom: 10px;
        font-weight: 600;
      }

      .header p {
        color: #5a7a5a;
        font-size: clamp(1rem, 2vw, 1.1rem);
      }

      .search-container {
        position: relative;
        margin-bottom: 30px;
        width: 66.666%;
        margin-left: auto;
        margin-right: auto;
      }

      .search-input {
        width: 100%;
        padding: 18px 24px;
        font-size: clamp(1rem, 2vw, 1.2rem);
        border: 3px solid #c4d9c4;
        border-radius: 16px;
        background: #ffffff;
        outline: none;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 2px 8px rgba(45, 90, 45, 0.1);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding-right: 48px;
      }

      .search-input:focus {
        border-color: #ff9966;
        box-shadow: 0 0 0 4px rgba(255, 153, 102, 0.2),
          0 4px 12px rgba(45, 90, 45, 0.15);
        transform: translateY(-1px);
      }

      .search-input::placeholder {
        color: #8fb48f;
      }

      .search-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: #ffffff;
        border: 3px solid #c4d9c4;
        border-top: none;
        border-radius: 0 0 16px 16px;
        max-height: calc(84px * 5);
        overflow-y: auto; /* remains scrollable when more than 5 results */
        overflow-x: hidden;
        z-index: 100;
        display: none;
        box-shadow: 0 8px 24px rgba(45, 90, 45, 0.15);
        /* visually hide scrollbar while keeping scrolling usable */
        -ms-overflow-style: none; /* IE 10+ */
        scrollbar-width: none; /* Firefox */
      }
      .search-results::-webkit-scrollbar {
        display: none;
      }
      .search-clear {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        font-size: 18px;
        cursor: pointer;
        color: #7a9a7a;
        padding: 6px 8px;
      }
      .search-clear:focus {
        outline: none;
      }

      .search-result-item {
        padding: 18px 24px;
        min-height: 56px;
        cursor: pointer;
        border-bottom: 1px solid #f0f8f0;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        color: #2d5a2d;
        font-size: 1rem;
        line-height: 1.3;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .search-result-item:hover,
      .search-result-item.selected {
        background: linear-gradient(135deg, #ff9966, #ffb399);
        color: white;
        transform: translateX(4px);
      }

      .search-result-item:hover small,
      .search-result-item.selected small {
        color: rgba(255, 255, 255, 0.8) !important;
      }

      .search-result-item:last-child {
        border-bottom: none;
      }

      .song-details {
        background: #ffffff;
        border: 3px solid #c4d9c4;
        border-radius: 16px;
        padding: 24px;
        min-height: 200px;
        box-shadow: 0 4px 16px rgba(45, 90, 45, 0.1);
        transition: all 0.3s ease;
        position: relative;
      }

      .song-details:hover {
        box-shadow: 0 6px 20px rgba(45, 90, 45, 0.15);
      }

      .song-details h2 {
        color: #2d5a2d;
        margin-bottom: 5px;
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        font-weight: 600;
      }

      .song-lyrics {
        background: #ffffff;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        font-size: clamp(0.9rem, 1.8vw, 1rem);
        line-height: 1.6;
        color: #2d5a2d;
        white-space: pre-line;
        text-align: left;
      }

      .no-results {
        text-align: center;
        color: #7a9a7a;
        font-style: italic;
        padding: 60px 20px;
        font-size: clamp(1rem, 2vw, 1.1rem);
      }

      @media (max-width: 768px) {
        body {
          padding: 15px;
        }

        .container {
          max-width: 100%;
        }

        .search-container {
          width: 100%;
          margin-left: 0;
          margin-right: 0;
        }

        .search-input {
          padding: 15px 20px;
        }

        .search-result-item {
          padding: 14px 20px;
        }

        .song-details {
          padding: 20px;
        }

        .song-lyrics {
          font-size: 0.9rem;
        }
      }

      @media (max-width: 480px) {
        .header {
          margin-bottom: 30px;
        }

        .search-input {
          padding: 12px 16px;
        }

        .search-result-item {
          padding: 12px 16px;
        }

        .song-details {
          padding: 16px;
        }

        /* Stack playlist and preview on very small screens only */
        .main-grid {
          grid-template-columns: 1fr !important;
          gap: 12px;
        }
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .search-results {
        animation: fadeIn 0.3s ease;
      }

      .search-input:focus-visible {
        outline: 3px solid #ff9966;
        outline-offset: 2px;
      }

      .search-result-item:focus {
        outline: 2px solid #ff9966;
        outline-offset: -2px;
      }

      /* Playlist & two-column layout */
      .main-grid {
        display: grid;
        grid-template-columns: minmax(240px, 1fr) 2fr;
        gap: 20px;
        align-items: start;
        margin-top: 20px;
      }

      .playlist-panel {
        width: 100%;
      }

      .right-panel {
        width: 100%;
      }

      /* Playlist header container */
      .playlist-header-container {
        margin-bottom: 16px;
      }

      .playlist-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
      }

      .playlist-title-container {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      #playlistTitle {
        flex: 1 1 auto;
        font-size: 1.2rem;
        font-weight: 600;
        color: #2d5a2d;
        margin: 0;
        padding: 8px 12px;
        border: 2px solid transparent;
        border-radius: 6px;
        background: transparent;
        outline: none;
        cursor: text;
        transition: all 0.2s ease;
      }

      .playlist-chevron {
        background: transparent;
        border: none;
        color: #7a9a7a;
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s ease;
      }

      .playlist-chevron:hover {
        background: #f0f8f0;
        color: #2d5a2d;
      }

      #playlistTitle:hover {
        background: #f8fdf8;
        border-color: #e0f0e0;
      }

      #playlistTitle:focus {
        background: #ffffff;
        border-color: #7fb07f;
        box-shadow: 0 0 0 3px rgba(127, 176, 127, 0.1);
      }

      /* Playlist selector dropdown */
      .playlist-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: #ffffff;
        border: 2px solid #c4d9c4;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(45, 90, 45, 0.15);
        z-index: 1000;
        max-height: 200px;
        overflow-y: auto;
        display: none;
      }

      .playlist-dropdown.show {
        display: block;
      }

      .playlist-option {
        padding: 10px 16px;
        cursor: pointer;
        border-bottom: 1px solid #f0f8f0;
        transition: background-color 0.15s ease;
      }

      .playlist-option:last-child {
        border-bottom: none;
      }

      .playlist-option:hover {
        background: #f8fdf8;
      }

      .playlist-option.current {
        background: #e8f5e8;
        font-weight: 600;
      }

      .playlist-select {
        width: 100%;
        padding: 10px 16px;
        font-size: 1rem;
        font-weight: 600;
        color: #2d5a2d;
        background: #f8fdf8;
        border: 2px solid #e0f0e0;
        border-radius: 8px;
        outline: none;
        cursor: pointer;
        transition: all 0.2s ease;
        appearance: none;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
        background-position: right 12px center;
        background-repeat: no-repeat;
        background-size: 16px;
        padding-right: 40px;
      }

      .playlist-select:hover {
        border-color: #c4d9c4;
        background: #ffffff;
      }

      .playlist-select:focus {
        border-color: #ff9966;
        box-shadow: 0 0 0 3px rgba(255, 153, 102, 0.1);
        background: #ffffff;
      }

      /* Playlist action buttons */
      .playlist-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .playlist-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        border-radius: 8px;
        border: 2px solid #e0f0e0;
        background: #f8fdf8;
        color: #5a7a5a;
        cursor: pointer;
        padding: 0;
        transition: all 0.2s ease;
      }

      .playlist-btn:hover {
        background: #2d5a2d;
        color: #ffffff;
        border-color: #2d5a2d;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(45, 90, 45, 0.2);
      }

      .playlist-btn:focus {
        outline: 2px solid #ff9966;
        outline-offset: 2px;
      }

      .playlist-btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(45, 90, 45, 0.2);
      }

      /* Ensure SVG icons inherit the button color */
      .playlist-btn svg {
        display: block;
        color: inherit;
        width: 18px;
        height: 18px;
      }

      .playlist-btn svg path,
      .playlist-btn svg circle,
      .playlist-btn svg rect {
        stroke: currentColor !important;
        fill: none !important;
      }

      /* Share button specific styling */
      .playlist-btn.shared {
        background: #ff9966;
        color: #ffffff;
        border-color: #ff9966;
      }

      .playlist-btn.shared:hover {
        background: #e8855c;
        border-color: #e8855c;
        color: #ffffff;
      }

      #ariaLive {
        position: absolute;
        left: -9999px;
        width: 1px;
        height: 1px;
        overflow: hidden;
      }

      .playlist-items {
        background: #ffffff;
        border: 3px solid #c4d9c4;
        border-radius: 12px;
        /* Allow playlist to grow vertically as items are added */
        max-height: none;
        overflow: visible;
      }

      /* If you later enable scrolling, keep the scrollbar visually minimal */
      .playlist-items::-webkit-scrollbar {
        height: 8px;
      }
      .playlist-items {
        -ms-overflow-style: auto;
        scrollbar-width: auto;
      }

      .playlist-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 14px;
        border-bottom: 1px solid #f0f8f0;
        gap: 12px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        position: relative;
        touch-action: pan-y;
      }

      .drag-handle {
        width: 18px;
        height: 18px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-right: 10px;
        color: #7a9a7a;
        cursor: grab;
        user-select: none;
        touch-action: none;
      }

      .dragging {
        opacity: 0.8;
        box-shadow: 0 8px 24px rgba(45, 90, 45, 0.25);
        border-radius: 8px;
      }

      /* Visual drop indicators */
      .playlist-item.drop-before::before,
      .playlist-item.drop-after::after {
        content: "";
        position: absolute;
        left: 12px;
        right: 12px;
        height: 3px;
        background: linear-gradient(90deg, #ff9966, #ffb399);
        border-radius: 2px;
        pointer-events: none;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06);
      }
      .playlist-item.drop-before::before {
        top: 0;
        transform: translateY(-50%);
      }
      .playlist-item.drop-after::after {
        bottom: 0;
        transform: translateY(50%);
      }

      /* Drop hint placeholder */
      .drop-hint {
        height: 4px;
        background: linear-gradient(90deg, #ff9966, #ffb399);
        border-radius: 2px;
        margin: 2px 12px;
        opacity: 0.8;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        animation: pulse 1s ease-in-out infinite alternate;
      }

      @keyframes pulse {
        from {
          opacity: 0.6;
        }
        to {
          opacity: 1;
        }
      }

      /* Sonar bounce when item was moved */
      @keyframes sonar {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 153, 102, 0.25);
        }
        70% {
          box-shadow: 0 0 0 18px rgba(255, 153, 102, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 153, 102, 0);
        }
      }
      .playlist-item.moved {
        animation: sonar 700ms ease-out;
      }

      /* Improve mobile touch targets */
      @media (max-width: 768px) {
        .drag-handle {
          width: 24px;
          height: 24px;
          margin-right: 12px;
        }

        .playlist-item {
          padding: 16px 14px;
          min-height: 56px;
        }

        .drag-handle:active {
          background: rgba(45, 90, 45, 0.1);
          border-radius: 4px;
        }
      }

      .playlist-item a {
        color: #2d5a2d;
        text-decoration: none;
        flex: 1 1 auto;
        overflow: hidden;
        text-overflow: ellipsis;
        display: inline-block;
      }

      .playlist-item small {
        display: block;
        color: #7a9a7a;
        font-size: 0.85em;
      }

      .playlist-item button.remove-item {
        margin-left: 8px;
        background: transparent;
        border: none;
        color: #7a9a7a;
        cursor: pointer;
        font-size: 16px;
      }

      .playlist-item small {
        display: block;
        color: #7a9a7a;
        font-size: 0.85em;
      }

      .playlist-item button.remove-item {
        margin-left: 8px;
        background: transparent;
        border: none;
        color: #7a9a7a;
        cursor: pointer;
        font-size: 16px;
      }

      /* Highlight the currently previewed playlist item */
      .playlist-item.selected {
        background: linear-gradient(135deg, #ff9966, #ffb399);
        color: white;
      }
      .playlist-item.selected a {
        color: inherit;
      }
      .playlist-item.selected small {
        color: rgba(255, 255, 255, 0.8);
      }

      /* Preview navigation buttons inside the song-details panel */
      .preview-nav {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }
      .preview-nav button {
        padding: 8px 12px;
        border-radius: 8px;
        border: 2px solid #e0f0e0;
        background: #f8fdf8;
        color: #5a7a5a;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s ease;
      }
      .preview-nav button:hover:not(:disabled) {
        background: #2d5a2d;
        color: #ffffff;
        border-color: #2d5a2d;
      }
      .preview-nav button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      /* Top navigation buttons */
      .top-nav {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        gap: 4px;
      }

      .top-nav button {
        width: 28px;
        height: 28px;
        border-radius: 6px;
        border: 2px solid #e0f0e0;
        background: #f8fdf8;
        color: #5a7a5a;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        padding: 0;
      }

      .top-nav button:hover:not(:disabled) {
        background: #2d5a2d;
        color: #ffffff;
        border-color: #2d5a2d;
        transform: scale(1.05);
      }

      .top-nav button:disabled {
        opacity: 0.35;
        cursor: not-allowed;
      }

      .top-nav button svg {
        width: 14px;
        height: 14px;
        stroke: currentColor;
        fill: none;
      }

      /* Settings section */
      .settings-section {
        position: absolute;
        top: 20px;
        right: 80px;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 1001;
      }

      .username-display {
        padding: 8px 12px;
        border-radius: 8px;
        border: 2px solid #e0f0e0;
        background: #f8fdf8;
        color: #5a7a5a;
        cursor: default;
        font-size: 0.8rem;
        font-weight: 600;
        transition: all 0.2s ease;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 120px;
        box-sizing: border-box;
        flex-shrink: 0;
      }

      .settings-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        border-radius: 8px;
        border: 2px solid #e0f0e0;
        background: #f8fdf8;
        color: #5a7a5a;
        cursor: pointer;
        padding: 0;
        transition: all 0.2s ease;
      }

      .settings-btn:hover {
        background: #2d5a2d;
        color: #ffffff;
        border-color: #2d5a2d;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(45, 90, 45, 0.2);
      }

      .settings-btn:focus {
        outline: 2px solid #ff9966;
        outline-offset: 2px;
      }

      .settings-btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(45, 90, 45, 0.2);
      }

      .settings-btn svg {
        display: block;
        color: inherit;
        width: 18px;
        height: 18px;
      }

      .settings-btn svg path,
      .settings-btn svg circle,
      .settings-btn svg rect {
        stroke: currentColor !important;
        fill: none !important;
      }

      /* Settings overlay */
      .settings-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 2000;
        display: none;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.2s ease;
      }

      .settings-overlay.show {
        display: flex;
      }

      .settings-form {
        background: #ffffff;
        border: 3px solid #c4d9c4;
        border-radius: 16px;
        padding: 24px;
        max-width: 400px;
        width: 90%;
        margin: auto;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from {
          transform: translateY(-20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .settings-form h3 {
        color: #2d5a2d;
        margin-bottom: 20px;
        font-size: 1.3rem;
        font-weight: 600;
        text-align: center;
      }

      .form-group {
        margin-bottom: 16px;
      }

      .form-group label {
        display: block;
        color: #2d5a2d;
        font-weight: 600;
        margin-bottom: 4px;
        font-size: 0.9rem;
      }

      .form-group input {
        width: 100%;
        padding: 12px 16px;
        font-size: 1rem;
        border: 2px solid #c4d9c4;
        border-radius: 8px;
        background: #ffffff;
        outline: none;
        transition: all 0.2s ease;
        box-sizing: border-box;
      }

      .form-group input:focus {
        border-color: #ff9966;
        box-shadow: 0 0 0 3px rgba(255, 153, 102, 0.1);
      }

      .form-buttons {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
        margin-top: 24px;
      }

      .form-btn {
        padding: 10px 20px;
        border-radius: 8px;
        border: 2px solid #e0f0e0;
        background: #f8fdf8;
        color: #5a7a5a;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.2s ease;
        min-width: 80px;
      }

      .form-btn.primary {
        background: #2d5a2d;
        border-color: #2d5a2d;
        color: #ffffff;
      }

      .form-btn:hover {
        background: #2d5a2d;
        border-color: #2d5a2d;
        color: #ffffff;
      }

      .form-btn.primary:hover {
        background: #1a3d1a;
        border-color: #1a3d1a;
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .header {
          position: relative;
          padding-top: 55px; /* Add space for settings section */
        }

        .settings-section {
          right: 15px;
          top: 15px;
          gap: 6px;
        }

        .username-display {
          padding: 6px 10px;
          max-width: 100px;
          font-size: 0.75rem;
        }

        .settings-btn {
          width: 36px;
          height: 36px;
        }

        .settings-btn svg {
          width: 16px;
          height: 16px;
        }

        .settings-form {
          padding: 20px;
          margin: 20px;
        }
      }

      @media (max-width: 480px) {
        .header {
          padding-top: 65px; /* More space on very small screens */
        }

        .settings-section {
          right: 10px;
          top: 10px;
          gap: 4px;
        }

        .username-display {
          padding: 5px 8px;
          max-width: 80px;
          font-size: 0.7rem;
        }

        .settings-btn {
          width: 32px;
          height: 32px;
        }

        .settings-btn svg {
          width: 14px;
          height: 14px;
        }
      }

      @media (max-width: 360px) {
        .settings-section {
          right: 8px;
          top: 8px;
          gap: 3px;
        }

        .username-display {
          padding: 4px 6px;
          max-width: 60px;
          font-size: 0.65rem;
        }

        .settings-btn {
          width: 28px;
          height: 28px;
        }

        .settings-btn svg {
          width: 12px;
          height: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- Settings section -->
        <div class="settings-section">
          <div
            id="usernameDisplay"
            class="username-display"
            style="display: none"
          ></div>
          <button
            id="settingsBtn"
            class="settings-btn"
            title="Nastavení"
            aria-label="Nastavení"
          >
            <svg
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M12 15a3 3 0 100-6 3 3 0 000 6z"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82v.79a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
        </div>
        <h1>🎵 Vyhledávání písní</h1>
      </div>

      <div class="search-container">
        <input
          type="text"
          id="searchInput"
          class="search-input"
          placeholder="Zadejte alespoň 2 znaky pro vyhledání písní..."
          autocomplete="off"
          autofocus
        />
        <button
          id="searchClearBtn"
          class="search-clear"
          aria-label="Vymazat hledání"
        >
          <svg
            width="14"
            height="14"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
            aria-hidden="true"
          >
            <path
              d="M18 6L6 18M6 6l12 12"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
        </button>
        <div id="searchResults" class="search-results"></div>
      </div>

      <div class="playlist-header-container">
        <div class="playlist-header" id="playlistHeader">
          <div style="flex: 1 1 auto; position: relative">
            <div class="playlist-title-container">
              <h2
                id="playlistTitle"
                contenteditable="true"
                spellcheck="false"
                tabindex="0"
                role="textbox"
                aria-label="Název playlistu"
              >
                Playlist
              </h2>
              <button
                id="playlistChevron"
                class="playlist-chevron"
                aria-label="Vybrat playlist"
                title="Vybrat playlist"
              >
                <svg
                  width="16"
                  height="16"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  aria-hidden="true"
                >
                  <path
                    d="M6 9l6 6 6-6"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </button>
            </div>
            <div id="playlistDropdown" class="playlist-dropdown"></div>
          </div>
          <div class="playlist-actions">
            <button
              id="newPlaylistBtn"
              class="playlist-btn"
              title="Nový playlist"
              aria-label="Nový playlist"
            >
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                aria-hidden="true"
              >
                <circle
                  cx="12"
                  cy="12"
                  r="9"
                  stroke="currentColor"
                  stroke-width="2"
                  fill="none"
                />
                <path
                  d="M12 8v8M8 12h8"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
            <button
              id="clearPlaylistBtn"
              class="playlist-btn"
              title="Vyprázdnit playlist"
              aria-label="Vyprázdnit playlist"
            >
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                aria-hidden="true"
              >
                <path
                  d="M3 3v18h18V3H3zm16 16H5V5h14v14z"
                  stroke="currentColor"
                  stroke-width="1.5"
                  fill="none"
                />
                <path
                  d="M8 8h8M8 12h8M8 16h5"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round"
                />
              </svg>
            </button>
            <button
              id="sharePlaylistBtn"
              class="playlist-btn"
              title="Sdílet playlist"
              aria-label="Sdílet playlist"
            >
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                aria-hidden="true"
              >
                <circle
                  cx="18"
                  cy="5"
                  r="3"
                  stroke="currentColor"
                  stroke-width="2"
                />
                <circle
                  cx="6"
                  cy="12"
                  r="3"
                  stroke="currentColor"
                  stroke-width="2"
                />
                <circle
                  cx="18"
                  cy="19"
                  r="3"
                  stroke="currentColor"
                  stroke-width="2"
                />
                <line
                  x1="8.59"
                  y1="13.51"
                  x2="15.42"
                  y2="17.49"
                  stroke="currentColor"
                  stroke-width="2"
                />
                <line
                  x1="15.41"
                  y1="6.51"
                  x2="8.59"
                  y2="10.49"
                  stroke="currentColor"
                  stroke-width="2"
                />
              </svg>
            </button>
            <button
              id="exportPlaylistBtn"
              class="playlist-btn"
              title="Exportovat playlist"
              aria-label="Exportovat playlist"
            >
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                aria-hidden="true"
              >
                <path
                  d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <polyline
                  points="7,10 12,15 17,10"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <line
                  x1="12"
                  y1="15"
                  x2="12"
                  y2="3"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
            </button>
            <button
              id="deletePlaylistBtn"
              class="playlist-btn"
              title="Smazat playlist"
              aria-label="Smazat playlist"
            >
              <svg
                width="18"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                aria-hidden="true"
              >
                <path
                  d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                <path
                  d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0v14m4-14v14"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
          </div>
          <div id="ariaLive" aria-live="polite" aria-atomic="true"></div>
        </div>
      </div>

      <div class="main-grid">
        <div class="playlist-panel">
          <div id="playlistItems" class="playlist-items">
            <!-- playlist entries go here -->
          </div>
        </div>

        <div class="right-panel">
          <div class="song-details">
            <div class="top-nav">
              <button
                id="prevInPlaylistTop"
                title="Předchozí v playlistu"
                aria-label="Předchozí položka"
              >
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="m15 18-6-6 6-6"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </button>
              <button
                id="nextInPlaylistTop"
                title="Další v playlistu"
                aria-label="Další položka"
              >
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="m9 18 6-6-6-6"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </button>
            </div>
            <h2 id="songDetailsTitle">Detail písně</h2>
            <div id="songDetailsContent" class="no-results">
              Vyberte píseň z výsledků vyhledávání pro zobrazení detailů
            </div>
            <div class="preview-nav">
              <button
                id="prevInPlaylist"
                title="Předchozí v playlistu"
                aria-label="Předchozí položka"
              >
                ◀ Předchozí
              </button>
              <button
                id="nextInPlaylist"
                title="Další v playlistu"
                aria-label="Další položka"
              >
                Další ▶
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Settings overlay -->
    <div
      id="settingsOverlay"
      class="settings-overlay"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
    >
      <div class="settings-form">
        <h3>Nastavení</h3>
        <form id="settingsForm">
          <div class="form-group">
            <label for="usernameInput">Uživatelské jméno:</label>
            <input
              type="text"
              id="usernameInput"
              name="username"
              placeholder="Zadejte uživatelské jméno"
            />
          </div>
          <div class="form-group">
            <label for="serverUrlInput">URL konfiguračního serveru:</label>
            <input
              type="url"
              id="serverUrlInput"
              name="serverUrl"
              placeholder="https://example.com/config"
            />
          </div>
          <div class="form-buttons">
            <button type="button" id="cancelSettingsBtn" class="form-btn">
              Zrušit
            </button>
            <button type="submit" id="saveSettingsBtn" class="form-btn primary">
              Uložit
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Accessible confirmation dialog -->
    <div
      id="confirmDialog"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
      style="
        display: none;
        position: fixed;
        inset: 0;
        align-items: center;
        justify-content: center;
        z-index: 2000;
      "
    >
      <div
        style="
          background: #fff;
          border: 3px solid #c4d9c4;
          border-radius: 12px;
          padding: 20px;
          max-width: 420px;
          width: 90%;
          margin: auto;
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        "
      >
        <div
          id="confirmDialogMessage"
          style="color: #2d5a2d; margin-bottom: 16px"
        >
          Potvrdit akci?
        </div>
        <div style="display: flex; gap: 8px; justify-content: flex-end">
          <button id="confirmNoBtn" class="playlist-btn" aria-label="Zrušit">
            Ne
          </button>
          <button id="confirmYesBtn" class="playlist-btn" aria-label="Potvrdit">
            Ano
          </button>
        </div>
      </div>
    </div>

    <script>
      // Songs, index and search state
      let songsData = {};
      let songIndex = {};
      let searchTimeout = null;
      let selectedIndex = -1;
      let currentResults = [];
      let dragSrcIndex = null;
      let lastMovedKey = null;
      let currentPreviewKey = null; // currently previewed songKey

      // Mobile touch drag state
      let touchDragState = {
        isDragging: false,
        startY: 0,
        currentY: 0,
        dragElement: null,
        dragIndex: -1,
        placeholder: null,
        dropHint: null,
      };

      // Playlist state
      const PLAYLISTS_KEY = "song_lab_playlists_v1";
      const SHARED_PLAYLISTS_KEY = "song_lab_shared_playlists_v1";
      let playlists = {}; // id -> { id, name, items: [{title, firstLine, songKey}] }
      let sharedPlaylists = {}; // id -> { sharedAt, sharedUrl }
      let currentPlaylistId = null;

      // Remote config / shared playlists fetched from server
      let remoteConfigOptions = [];
      let remotePlaylistQuery = null;
      let remotePlaylists = [];
      let remotePlaylistsLoaded = false;
      let remotePlaylistsError = null;

      function removeAccents(str) {
        return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      }

      async function loadSongsData() {
        try {
          const response = await fetch("songs.json");
          songsData = await response.json();

          songIndex = {};
          Object.keys(songsData).forEach((title) => {
            const firstLine = getFirstLine(songsData[title]);
            songIndex[title] = {
              title: title,
              displayTitle: cleanTitleForDisplay(title),
              firstLine: firstLine,
              titleTrigrams: createPostgresStyleTrigrams(title),
              firstLineTrigrams: createPostgresStyleTrigrams(firstLine),
              data: songsData[title],
            };
          });

          console.log("Songs data loaded:", Object.keys(songsData).length);
        } catch (err) {
          console.error("Error loading songs.json", err);
          document.getElementById("songDetailsContent").innerHTML =
            '<div class="no-results">Chyba při načítání dat písní. Zkontrolujte, zda existuje soubor songs.json.</div>';
        }
      }

      function normalizeText(text) {
        return removeAccents(text || "")
          .toLowerCase()
          .replace(/[^a-z0-9\s]/g, "")
          .replace(/\s+/g, " ")
          .trim();
      }

      function cleanTitleForDisplay(title) {
        const idx = title.indexOf(";");
        if (idx !== -1) return title.substring(0, idx).trim();
        return title;
      }

      function getFirstLine(songData) {
        if (!songData) return "";
        if (
          !songData.sections ||
          !Array.isArray(songData.sections) ||
          songData.sections.length === 0
        )
          return "";
        const firstSection = songData.sections[0];
        if (
          !firstSection.slides ||
          !Array.isArray(firstSection.slides) ||
          firstSection.slides.length === 0
        )
          return "";
        const firstSlide = firstSection.slides[0];
        if (!Array.isArray(firstSlide) || firstSlide.length === 0) return "";
        return firstSlide[0];
      }

      function createPostgresStyleTrigrams(text) {
        const normalized = normalizeText(text);
        const padded = "  " + normalized + " ";
        const trigrams = new Set();
        for (let i = 0; i < padded.length - 2; i++)
          trigrams.add(padded.substring(i, i + 3));
        return Array.from(trigrams);
      }

      function calculateSimilarity(t1, t2) {
        const s1 = new Set(t1 || []);
        const s2 = new Set(t2 || []);
        const inter = new Set([...s1].filter((x) => s2.has(x)));
        const union = new Set([...s1, ...s2]);
        return union.size === 0 ? 0 : inter.size / union.size;
      }

      function searchSongs(query) {
        if (!query || query.length < 2) return [];
        const MIN_SIMILARITY = query.length <= 3 ? 0.12 : 0.1;
        const qTr = createPostgresStyleTrigrams(query);
        const res = [];
        Object.keys(songIndex).forEach((key) => {
          const idx = songIndex[key];
          const titleSim = calculateSimilarity(qTr, idx.titleTrigrams);
          const lineSim = calculateSimilarity(qTr, idx.firstLineTrigrams);
          const combined = Math.max(titleSim * 1.2, lineSim);
          const nq = normalizeText(query);
          const nt = normalizeText(idx.title);
          if (nt.startsWith(nq) && nq.length >= 2) {
            res.push({
              ...idx,
              similarity: Math.max(0.95, combined),
              titleMatch: true,
              songKey: key,
            });
            return;
          }
          if (combined >= MIN_SIMILARITY)
            res.push({
              ...idx,
              similarity: combined,
              titleMatch: titleSim > lineSim,
              songKey: key,
            });
        });
        return res.sort((a, b) => b.similarity - a.similarity).slice(0, 10);
      }

      // --- DOM: results rendering (unchanged semantics) ---
      function displayResults(results) {
        const container = document.getElementById("searchResults");
        if (!results || results.length === 0) {
          container.style.display = "none";
          return;
        }
        container.innerHTML = "";
        currentResults = results.slice(0, 5);
        selectedIndex = 0;
        currentResults.forEach((r, i) => {
          const div = document.createElement("div");
          div.className = "search-result-item";
          if (i === 0) div.classList.add("selected");
          const firstLineHtml = r.firstLine
            ? `<small style="color:#7a9a7a;font-size:0.85em;display:block;margin-top:4px">${r.firstLine}</small>`
            : "";
          div.innerHTML = `${r.displayTitle}${firstLineHtml}`;
          div.dataset.index = i;
          div.addEventListener("click", () => onSearchResultClick(r));
          div.addEventListener("mouseenter", () => {
            clearSelection();
            selectedIndex = i;
            div.classList.add("selected");
          });
          container.appendChild(div);
        });
        container.style.display = "block";
      }

      function clearSelection() {
        document
          .querySelectorAll(".search-result-item")
          .forEach((el) => el.classList.remove("selected"));
      }

      function handleSearch() {
        const q = document.getElementById("searchInput").value.trim();
        if (searchTimeout) clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          if (!q || q.length < 2) {
            document.getElementById("searchResults").style.display = "none";
            return;
          }
          const r = searchSongs(q);
          displayResults(r);
        }, 100);
      }

      function handleKeydown(e) {
        const container = document.getElementById("searchResults");
        if (e.key === "Escape") {
          e.preventDefault();
          clearSearch();
          return;
        }
        if (e.key === "Tab") {
          if (container.style.display !== "none" && currentResults.length > 0) {
            e.preventDefault();
            onSearchResultClick(currentResults[0]);
          }
          return;
        }
        if (container.style.display === "none" || currentResults.length === 0)
          return;
        switch (e.key) {
          case "ArrowDown":
            e.preventDefault();
            moveSelection(1);
            break;
          case "ArrowUp":
            e.preventDefault();
            moveSelection(-1);
            break;
          case "Enter":
            e.preventDefault();
            if (selectedIndex >= 0 && selectedIndex < currentResults.length)
              onSearchResultClick(currentResults[selectedIndex]);
            break;
        }
      }

      function moveSelection(dir) {
        const items = document.querySelectorAll(".search-result-item");
        if (items.length === 0) return;
        let ni = selectedIndex + dir;
        if (ni < 0) ni = 0;
        if (ni >= items.length) ni = items.length - 1;
        if (ni === selectedIndex) return;
        clearSelection();
        selectedIndex = ni;
        if (items[selectedIndex]) {
          items[selectedIndex].classList.add("selected");
          items[selectedIndex].scrollIntoView({ block: "nearest" });
        }
      }

      function hideResults() {
        document.getElementById("searchResults").style.display = "none";
        selectedIndex = -1;
        currentResults = [];
      }
      function clearSearch() {
        const si = document.getElementById("searchInput");
        si.value = "";
        hideResults();
        si.focus();
      }

      function focusSearch() {
        // Don't focus search input during drag operations on mobile
        if (touchDragState.isDragging) return;
        try {
          const si = document.getElementById("searchInput");
          if (si) {
            si.focus();
            si.select && si.select();
          }
        } catch (e) {}
      }

      function onSearchResultClick(result) {
        // Add to playlist instead of clearing only
        addSongToCurrentPlaylist({
          title: result.displayTitle,
          firstLine: result.firstLine || "",
          songKey: result.songKey,
        });
        // show preview for that song
        showSongPreview(result.songKey);
        hideResults();
        const si = document.getElementById("searchInput");
        si.value = "";
      }

      function selectSong(result) {
        // kept for backward compatibility
        showSongPreview(result.songKey || result.title);
      }

      function formatSongContent(songData) {
        let out = "";
        if (!songData) return out;

        // Check if outline exists and is valid
        if (
          songData.outline &&
          Array.isArray(songData.outline) &&
          songData.outline.length > 0
        ) {
          // Create a map of section IDs to sections for quick lookup
          const sectionMap = {};
          if (songData.sections && Array.isArray(songData.sections)) {
            songData.sections.forEach((section) => {
              if (section.id) {
                sectionMap[section.id] = section;
              }
            });
          }

          // Validate outline - check if all IDs exist in sections
          const isValidOutline = songData.outline.every((id) => sectionMap[id]);

          if (isValidOutline) {
            // Use outline to render sections in specified order
            songData.outline.forEach((sectionId, oi) => {
              const section = sectionMap[sectionId];
              if (section && section.slides) {
                section.slides.forEach((slide) => {
                  if (Array.isArray(slide))
                    slide.forEach((line) => (out += line + "\n"));
                });
                if (oi < songData.outline.length - 1) out += "\n";
              }
            });
            return out.trim();
          }
        }

        // Fallback to original behavior if no valid outline
        songData.sections &&
          songData.sections.forEach((section, si) => {
            section.slides &&
              section.slides.forEach((slide) => {
                if (Array.isArray(slide))
                  slide.forEach((line) => (out += line + "\n"));
              });
            if (si < songData.sections.length - 1) out += "\n";
          });
        return out.trim();
      }

      function showSongPreview(songKey, scrollToDetails = false) {
        currentPreviewKey = songKey;
        const data = songsData[songKey];
        const titleEl = document.getElementById("songDetailsTitle");
        const contentEl = document.getElementById("songDetailsContent");
        if (!data) {
          titleEl.textContent = "Detail písně";
          contentEl.innerHTML =
            '<div class="no-results">Vyberte píseň z výsledků vyhledávání pro zobrazení detailů</div>';
          updatePreviewNavButtons();
          renderCurrentPlaylist();
          return;
        }
        titleEl.textContent = cleanTitleForDisplay(songKey);
        contentEl.innerHTML = `<div class="song-lyrics">${formatSongContent(
          data
        )}</div>`;
        updatePreviewNavButtons();
        renderCurrentPlaylist();

        if (scrollToDetails) {
          // scroll to song details section and scroll content to top
          try {
            const songDetails = document.querySelector(".song-details");
            if (songDetails) {
              // On mobile, ensure there's enough space to scroll song details to viewport top
              const isMobile = window.innerWidth <= 768;
              if (isMobile) {
                // Get the position of song details
                const rect = songDetails.getBoundingClientRect();
                const targetY = window.scrollY + rect.top;

                // Add temporary bottom padding to ensure we can scroll to target
                const tempPadding = document.createElement("div");
                tempPadding.style.height = window.innerHeight + "px";
                tempPadding.style.pointerEvents = "none";
                tempPadding.id = "temp-scroll-padding";
                document.body.appendChild(tempPadding);

                // Scroll to exact position
                setTimeout(() => {
                  window.scrollTo({ top: targetY, behavior: "smooth" });

                  // After scroll completes, remove padding but maintain position
                  setTimeout(() => {
                    if (tempPadding && tempPadding.parentNode) {
                      // Instead of removing immediately, fade it out gradually
                      tempPadding.style.transition = "height 0.5s ease-out";
                      tempPadding.style.height = "0px";

                      // Remove after transition
                      setTimeout(() => {
                        if (tempPadding.parentNode) {
                          tempPadding.remove();
                        }
                      }, 500);
                    }
                  }, 800);
                }, 50);
              } else {
                songDetails.scrollIntoView({
                  behavior: "smooth",
                  block: "start",
                });
              }
            }
            // Also scroll the content area to the top
            const contentEl = document.getElementById("songDetailsContent");
            if (contentEl) {
              contentEl.scrollTop = 0;
            }
          } catch (e) {}
        } else {
          // scroll selected playlist item into view
          try {
            const container = document.getElementById("playlistItems");
            const selected =
              container && container.querySelector(".playlist-item.selected");
            if (selected && selected.scrollIntoView)
              selected.scrollIntoView({ behavior: "smooth", block: "nearest" });
          } catch (e) {}
        }
      }

      function clearSongPreview() {
        currentPreviewKey = null;
        const titleEl = document.getElementById("songDetailsTitle");
        const contentEl = document.getElementById("songDetailsContent");
        titleEl.textContent = "Detail písně";
        contentEl.innerHTML =
          '<div class="no-results">Vyberte píseň z výsledků vyhledávání pro zobrazení detailů</div>';
        updatePreviewNavButtons();
        renderCurrentPlaylist();
      }

      // --- Playlist management (in-memory + localStorage) ---
      function loadPlaylists() {
        try {
          const raw = localStorage.getItem(PLAYLISTS_KEY);
          playlists = raw ? JSON.parse(raw) : {};
        } catch (e) {
          playlists = {};
        }
        // ensure at least one playlist exists
        if (!Object.keys(playlists).length) {
          const id = createNewPlaylist("Nový playlist");
          currentPlaylistId = id;
        } else {
          currentPlaylistId = Object.keys(playlists)[0];
        }
        loadSharedPlaylists();
        updatePlaylistTitle();
        renderCurrentPlaylist();
        updateShareButton();
      }

      function savePlaylists() {
        try {
          localStorage.setItem(PLAYLISTS_KEY, JSON.stringify(playlists));
        } catch (e) {
          console.error("Failed to save playlists", e);
        }
      }

      function createNewPlaylist(name) {
        const id = "pl_" + Date.now();
        playlists[id] = { id, name: name || "Nový playlist", items: [] };
        savePlaylists();
        currentPlaylistId = id;
        updatePlaylistTitle();
        renderCurrentPlaylist();
        clearSongPreview();
        updateShareButton();
        // announce creation for screen readers
        try {
          const ariaLive = document.getElementById("ariaLive");
          if (ariaLive)
            ariaLive.textContent =
              "Vytvořen playlist " + (playlists[id].name || "");
        } catch (e) {}
        focusSearch();
        return id;
      }

      function deleteCurrentPlaylist() {
        if (!currentPlaylistId) return;
        openConfirm("Smazat tento playlist?").then((ok) => {
          if (!ok) return;
          const deletedName = playlists[currentPlaylistId]
            ? playlists[currentPlaylistId].name
            : "";
          delete playlists[currentPlaylistId];
          const keys = Object.keys(playlists);
          currentPlaylistId = keys.length
            ? keys[0]
            : createNewPlaylist("Nový playlist");
          savePlaylists();
          updatePlaylistTitle();
          renderCurrentPlaylist();
          clearSongPreview();
          updateShareButton();
          // announce deletion
          try {
            const ariaLive = document.getElementById("ariaLive");
            if (ariaLive)
              ariaLive.textContent = "Playlist smazán: " + deletedName;
          } catch (e) {}
          focusSearch();
        });
      }

      function updatePlaylistTitle() {
        const titleEl = document.getElementById("playlistTitle");
        if (!titleEl) return;
        if (currentPlaylistId && playlists[currentPlaylistId]) {
          titleEl.textContent = playlists[currentPlaylistId].name || "Playlist";
        } else {
          titleEl.textContent = "Playlist";
        }
      }

      function onPlaylistTitleEdit() {
        const titleEl = document.getElementById("playlistTitle");
        if (!titleEl || !currentPlaylistId || !playlists[currentPlaylistId])
          return;

        const newName = titleEl.textContent.trim() || "Playlist";

        // Update the visual display if it was empty
        if (titleEl.textContent.trim() === "") {
          titleEl.textContent = "Playlist";
        }

        if (newName !== playlists[currentPlaylistId].name) {
          playlists[currentPlaylistId].name = newName;
          savePlaylists();
          try {
            const ariaLive = document.getElementById("ariaLive");
            if (ariaLive)
              ariaLive.textContent = "Playlist přejmenován na: " + newName;
          } catch (e) {}
        }
        focusSearch();
      }

      function showPlaylistDropdown() {
        const dropdown = document.getElementById("playlistDropdown");
        if (!dropdown) return;

        dropdown.innerHTML = "";

        // Local playlists
        Object.keys(playlists).forEach((id) => {
          const option = document.createElement("div");
          option.className =
            "playlist-option" + (id === currentPlaylistId ? " current" : "");
          option.textContent = playlists[id].name || "Playlist";
          option.addEventListener("click", () => {
            currentPlaylistId = id;
            updatePlaylistTitle();
            renderCurrentPlaylist();
            clearSongPreview();
            updateShareButton();
            hidePlaylistDropdown();
            try {
              const ariaLive = document.getElementById("ariaLive");
              if (ariaLive)
                ariaLive.textContent =
                  "Přepnuto na playlist: " + (playlists[id].name || "Playlist");
            } catch (e) {}
            focusSearch();
          });
          dropdown.appendChild(option);
        });

        // Separator if we have remote playlists
        if (remotePlaylists && remotePlaylists.length) {
          const sep = document.createElement("div");
          sep.className = "playlist-option";
          sep.style.cursor = "default";
          sep.style.fontWeight = "600";
          sep.style.background = "#f8fdf8";
          sep.textContent = "— Sdílené playlisty —";
          dropdown.appendChild(sep);

          remotePlaylists.forEach((rp) => {
            const label = rp.playlistId || rp.name || "Sdílený playlist";
            const opt = document.createElement("div");
            opt.className = "playlist-option";
            opt.textContent = label;
            opt.title = label;
            opt.addEventListener("click", () => {
              hidePlaylistDropdown();
              importRemotePlaylist(rp);
            });
            dropdown.appendChild(opt);
          });
        } else if (remotePlaylistsLoaded && remotePlaylistsError) {
          const err = document.createElement("div");
          err.className = "playlist-option";
          err.style.cursor = "default";
          err.style.color = "#b45309";
          err.textContent =
            "Chyba sdílených playlistů: " + remotePlaylistsError;
          dropdown.appendChild(err);
        } else if (!remotePlaylistsLoaded) {
          const loading = document.createElement("div");
          loading.className = "playlist-option";
          loading.style.cursor = "default";
          loading.textContent = "Načítání sdílených playlistů…";
          dropdown.appendChild(loading);
        }

        dropdown.classList.add("show");
      }

      function hidePlaylistDropdown() {
        const dropdown = document.getElementById("playlistDropdown");
        if (dropdown) {
          dropdown.classList.remove("show");
        }
      }

      function renderCurrentPlaylist() {
        const container = document.getElementById("playlistItems");
        container.innerHTML = "";
        container.setAttribute("role", "list");
        if (!currentPlaylistId || !playlists[currentPlaylistId]) return;
        const pl = playlists[currentPlaylistId];
        pl.items.forEach((it, idx) => {
          const row = document.createElement("div");
          row.className = "playlist-item";
          if (currentPreviewKey && it.songKey === currentPreviewKey) {
            row.classList.add("selected");
            row.setAttribute("aria-current", "true");
          } else {
            row.removeAttribute("aria-current");
          }
          row.setAttribute("role", "listitem");
          row.draggable = true;

          const handle = document.createElement("div");
          handle.className = "drag-handle";
          handle.innerHTML =
            '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M3 6h18M3 12h18M3 18h18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
          handle.title = "Táhnout pro přesunutí";

          const a = document.createElement("a");
          a.href = "#";
          a.setAttribute("tabindex", "0");
          a.setAttribute(
            "aria-label",
            (it.title || "") + (it.firstLine ? " — " + it.firstLine : "")
          );
          a.innerHTML = `<strong>${it.title}</strong>${
            it.firstLine ? "<small>" + it.firstLine + "</small>" : ""
          }`;
          a.addEventListener("click", (ev) => {
            ev.preventDefault();
            showSongPreview(it.songKey, true);
          });
          a.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter" || ev.key === " ") {
              ev.preventDefault();
              showSongPreview(it.songKey, true);
            }
          });

          const removeBtn = document.createElement("button");
          removeBtn.className = "remove-item";
          removeBtn.title = "Odstranit";
          removeBtn.setAttribute("aria-label", "Odstranit položku");
          removeBtn.innerHTML =
            '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
          removeBtn.addEventListener("click", () => {
            removeItemFromPlaylist(idx);
          });

          row.appendChild(handle);
          row.appendChild(a);
          row.appendChild(removeBtn);
          // if this row corresponds to the last moved item, add moved class briefly
          if (lastMovedKey && it.songKey === lastMovedKey) {
            row.classList.add("moved");
            // clear the marker after the animation ends
            row.addEventListener(
              "animationend",
              () => {
                row.classList.remove("moved");
                lastMovedKey = null;
              },
              { once: true }
            );
          }
          container.appendChild(row);

          // drag events with visual insert cue
          row.addEventListener("dragstart", (e) => {
            dragSrcIndex = idx;
            row.classList.add("dragging");
            e.dataTransfer.effectAllowed = "move";
            try {
              e.dataTransfer.setData("text/plain", String(idx));
            } catch (err) {}
          });

          row.addEventListener("dragend", (e) => {
            dragSrcIndex = null;
            // clear all drop cues
            document
              .querySelectorAll(
                ".playlist-item.drop-before, .playlist-item.drop-after"
              )
              .forEach((el) =>
                el.classList.remove("drop-before", "drop-after")
              );
            row.classList.remove("dragging");
          });

          row.addEventListener("dragover", (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";
            // compute whether we should show before or after based on mouse position
            const rect = row.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            const isBefore = e.clientY < midY;
            // clear cues on all rows first
            document
              .querySelectorAll(
                ".playlist-item.drop-before, .playlist-item.drop-after"
              )
              .forEach((el) =>
                el.classList.remove("drop-before", "drop-after")
              );
            if (isBefore) row.classList.add("drop-before");
            else row.classList.add("drop-after");
          });

          row.addEventListener("dragleave", (e) => {
            row.classList.remove("drag-over", "drop-before", "drop-after");
          });

          row.addEventListener("drop", (e) => {
            e.preventDefault();
            row.classList.remove("drag-over");
            const from =
              dragSrcIndex !== null
                ? dragSrcIndex
                : parseInt(
                    (e.dataTransfer &&
                      e.dataTransfer.getData &&
                      e.dataTransfer.getData("text/plain")) ||
                      -1,
                    10
                  );
            if (from === -1) return;
            const rect = row.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            const insertBefore = e.clientY < midY;
            const pl = playlists[currentPlaylistId];
            const moved = pl.items.splice(from, 1)[0];
            let insertAt = idx;
            // if inserting after the target, and source was before, adjust index
            if (!insertBefore) insertAt = idx + 1;
            if (from < insertAt) insertAt--; // account for removal shifting indexes
            pl.items.splice(insertAt, 0, moved);
            savePlaylists();
            // remember key for visual feedback
            lastMovedKey = moved.songKey || null;
            renderCurrentPlaylist();
            // Don't focus search after drag operation
          });

          // Mobile touch drag events
          handle.addEventListener("touchstart", (e) => {
            e.preventDefault();
            const touch = e.touches[0];

            // Blur search input to prevent keyboard from showing after drag
            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
              searchInput.blur();
            }

            touchDragState.isDragging = true;
            touchDragState.startY = touch.clientY;
            touchDragState.currentY = touch.clientY;
            touchDragState.dragElement = row;
            touchDragState.dragIndex = idx;
            row.classList.add("dragging");

            // Create placeholder
            touchDragState.placeholder = row.cloneNode(true);
            touchDragState.placeholder.style.opacity = "0.3";
            touchDragState.placeholder.style.pointerEvents = "none";
            touchDragState.placeholder.classList.add("placeholder");
          });

          row.addEventListener("touchmove", (e) => {
            if (
              !touchDragState.isDragging ||
              touchDragState.dragElement !== row
            )
              return;
            e.preventDefault();

            const touch = e.touches[0];
            touchDragState.currentY = touch.clientY;
            const deltaY = touchDragState.currentY - touchDragState.startY;

            // Move the dragged element
            row.style.transform = `translateY(${deltaY}px)`;
            row.style.zIndex = "1000";

            // Remove any existing drop hint
            if (touchDragState.dropHint) {
              touchDragState.dropHint.remove();
              touchDragState.dropHint = null;
            }

            // Find all playlist items (excluding the dragged one)
            const allItems = Array.from(container.children).filter(
              (item) => item.classList.contains("playlist-item") && item !== row
            );

            let targetItem = null;
            let insertBefore = false;

            // Find which item we're dropping on/near
            for (let i = 0; i < allItems.length; i++) {
              const item = allItems[i];
              const rect = item.getBoundingClientRect();
              const midY = rect.top + rect.height / 2;

              if (touch.clientY <= rect.bottom) {
                targetItem = item;
                insertBefore = touch.clientY < midY;
                break;
              }
            }

            // Create and position drop hint
            touchDragState.dropHint = document.createElement("div");
            touchDragState.dropHint.className = "drop-hint";

            if (targetItem) {
              if (insertBefore) {
                container.insertBefore(touchDragState.dropHint, targetItem);
              } else {
                if (targetItem.nextSibling) {
                  container.insertBefore(
                    touchDragState.dropHint,
                    targetItem.nextSibling
                  );
                } else {
                  container.appendChild(touchDragState.dropHint);
                }
              }
            } else if (allItems.length > 0) {
              // Drop at the end
              container.appendChild(touchDragState.dropHint);
            }
          });

          row.addEventListener("touchend", (e) => {
            if (
              !touchDragState.isDragging ||
              touchDragState.dragElement !== row
            )
              return;
            e.preventDefault();

            const touch = e.changedTouches[0];
            const sourceIndex = touchDragState.dragIndex;

            // Reset visual state
            row.style.transform = "";
            row.style.zIndex = "";
            row.classList.remove("dragging");

            // Remove drop hint and use its position to determine where to insert
            let insertAtIndex = sourceIndex; // default to no change

            if (touchDragState.dropHint && touchDragState.dropHint.parentNode) {
              // Find the position of the drop hint in the container
              const hintIndex = Array.from(container.children).indexOf(
                touchDragState.dropHint
              );

              // Convert hint position to array index
              const itemsBefore = Array.from(container.children)
                .slice(0, hintIndex)
                .filter((child) =>
                  child.classList.contains("playlist-item")
                ).length;

              insertAtIndex = itemsBefore;

              // Adjust for the source item being removed
              if (sourceIndex < insertAtIndex) {
                insertAtIndex--;
              }

              touchDragState.dropHint.remove();
              touchDragState.dropHint = null;
            }

            // Clear drop indicators
            document
              .querySelectorAll(
                ".playlist-item.drop-before, .playlist-item.drop-after"
              )
              .forEach((el) => {
                el.classList.remove("drop-before", "drop-after");
              });

            // Perform the move if the position actually changes
            if (insertAtIndex !== sourceIndex && sourceIndex !== -1) {
              const pl = playlists[currentPlaylistId];
              const moved = pl.items.splice(sourceIndex, 1)[0];
              pl.items.splice(
                Math.min(insertAtIndex, pl.items.length),
                0,
                moved
              );
              savePlaylists();
              lastMovedKey = moved.songKey || null;
              renderCurrentPlaylist();
              // Don't focus search after drag operation
            }

            // Reset touch drag state
            touchDragState.isDragging = false;
            touchDragState.dragElement = null;
            touchDragState.dragIndex = -1;
            touchDragState.placeholder = null;
          });
        });
      }

      function addSongToCurrentPlaylist(item) {
        if (!currentPlaylistId || !playlists[currentPlaylistId]) return;
        // dedupe by songKey: if exists, move it to the end and show preview
        const pl = playlists[currentPlaylistId];
        const existingIdx = pl.items.findIndex(
          (i) => i.songKey === item.songKey
        );
        if (existingIdx !== -1) {
          // move it to the end
          const existing = pl.items.splice(existingIdx, 1)[0];
          pl.items.push(existing);
          savePlaylists();
          // remember key for visual feedback
          lastMovedKey = existing.songKey || null;
          renderCurrentPlaylist();
          // show the preview for the existing item
          showSongPreview(item.songKey);
          // announce moved to end
          try {
            const ariaLive = document.getElementById("ariaLive");
            if (ariaLive)
              ariaLive.textContent = "Položka přesunuta na konec playlistu";
          } catch (e) {}
          focusSearch();
          return;
        }
        // append new item to the end
        pl.items.push(item);
        // keep playlist reasonably bounded (optional limit 200) - remove oldest items from start
        while (pl.items.length > 200) pl.items.shift();
        savePlaylists();
        // mark newly added item for feedback
        lastMovedKey = item.songKey || null;
        renderCurrentPlaylist();
        // announce addition
        try {
          const ariaLive = document.getElementById("ariaLive");
          if (ariaLive)
            ariaLive.textContent = "Přidána položka: " + (item.title || "");
        } catch (e) {}
        focusSearch();
      }

      function removeItemFromPlaylist(index) {
        if (!currentPlaylistId || !playlists[currentPlaylistId]) return;
        const removed = playlists[currentPlaylistId].items[index];
        playlists[currentPlaylistId].items.splice(index, 1);
        savePlaylists();
        renderCurrentPlaylist();
        try {
          const ariaLive = document.getElementById("ariaLive");
          if (ariaLive)
            ariaLive.textContent =
              "Položka odstraněna: " + (removed ? removed.title || "" : "");
        } catch (e) {}
        focusSearch();
      }

      function clearPlaylist() {
        if (!currentPlaylistId || !playlists[currentPlaylistId]) return;
        openConfirm("Vymazat všechny položky v playlistu?").then((ok) => {
          if (!ok) return;
          playlists[currentPlaylistId].items = [];
          savePlaylists();
          renderCurrentPlaylist();
          clearSongPreview();
          try {
            const ariaLive = document.getElementById("ariaLive");
            if (ariaLive) ariaLive.textContent = "Playlist vyprázdněn";
          } catch (e) {}
          focusSearch();
        });
      }

      // --- preview navigation helpers ---
      function updatePreviewNavButtons() {
        const prevBtn = document.getElementById("prevInPlaylist");
        const nextBtn = document.getElementById("nextInPlaylist");
        const prevTopBtn = document.getElementById("prevInPlaylistTop");
        const nextTopBtn = document.getElementById("nextInPlaylistTop");

        const buttons = [prevBtn, nextBtn, prevTopBtn, nextTopBtn].filter(
          Boolean
        );
        if (buttons.length === 0) return;

        if (
          !currentPlaylistId ||
          !playlists[currentPlaylistId] ||
          !currentPreviewKey
        ) {
          buttons.forEach((btn) => (btn.disabled = true));
          return;
        }

        const pl = playlists[currentPlaylistId];
        const idx = pl.items.findIndex((i) => i.songKey === currentPreviewKey);
        if (idx === -1) {
          buttons.forEach((btn) => (btn.disabled = true));
          return;
        }

        const isPrevDisabled = idx <= 0;
        const isNextDisabled = idx >= pl.items.length - 1;

        if (prevBtn) prevBtn.disabled = isPrevDisabled;
        if (nextBtn) nextBtn.disabled = isNextDisabled;
        if (prevTopBtn) prevTopBtn.disabled = isPrevDisabled;
        if (nextTopBtn) nextTopBtn.disabled = isNextDisabled;
      }

      function prevInPlaylist() {
        if (
          !currentPlaylistId ||
          !playlists[currentPlaylistId] ||
          !currentPreviewKey
        )
          return;
        const pl = playlists[currentPlaylistId];
        const idx = pl.items.findIndex((i) => i.songKey === currentPreviewKey);
        if (idx > 0) showSongPreview(pl.items[idx - 1].songKey, true);
      }

      function nextInPlaylist() {
        if (
          !currentPlaylistId ||
          !playlists[currentPlaylistId] ||
          !currentPreviewKey
        )
          return;
        const pl = playlists[currentPlaylistId];
        const idx = pl.items.findIndex((i) => i.songKey === currentPreviewKey);
        if (idx >= 0 && idx < pl.items.length - 1)
          showSongPreview(pl.items[idx + 1].songKey, true);
      }

      // Export playlist functionality
      function exportCurrentPlaylist() {
        if (!currentPlaylistId || !playlists[currentPlaylistId]) return;

        const pl = playlists[currentPlaylistId];
        const playlistName = pl.name || "Playlist";

        // Generate XML content matching gen-playlist.sh format
        let xmlContent = '<?xml version="1.0" encoding="UTF-8"?>\n';
        xmlContent += `<set name="${escapeXml(playlistName)}">\n`;
        xmlContent += "  <slide_groups>\n";

        pl.items.forEach((item) => {
          if (
            item.songKey &&
            songsData[item.songKey] &&
            songsData[item.songKey].file
          ) {
            // Use the file property from songs.json which already has .xml extension
            const fileName = songsData[item.songKey].file;
            xmlContent += `    <slide_group name="${escapeXml(
              fileName
            )}" type="song" presentation="" path=""/>\n`;
          }
        });

        xmlContent += "  </slide_groups>\n";
        xmlContent += "</set>\n";

        // Create and download file using playlist name as filename
        downloadTextFile(xmlContent, playlistName);

        // Announce export for screen readers
        try {
          const ariaLive = document.getElementById("ariaLive");
          if (ariaLive)
            ariaLive.textContent = "Playlist exportován: " + playlistName;
        } catch (e) {}
      }

      function escapeXml(str) {
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function downloadTextFile(content, filename) {
        const blob = new Blob([content], { type: "text/xml;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename; // No .xml extension - use playlist name directly
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // --- Shared playlists management ---
      function loadSharedPlaylists() {
        try {
          const raw = localStorage.getItem(SHARED_PLAYLISTS_KEY);
          sharedPlaylists = raw ? JSON.parse(raw) : {};
        } catch (e) {
          sharedPlaylists = {};
        }
      }

      function saveSharedPlaylists() {
        try {
          localStorage.setItem(
            SHARED_PLAYLISTS_KEY,
            JSON.stringify(sharedPlaylists)
          );
        } catch (e) {
          console.error("Failed to save shared playlists", e);
        }
      }

      function getUsernameFromSettings() {
        try {
          const settings = JSON.parse(
            localStorage.getItem("song_lab_settings") || "{}"
          );
          return settings.username && settings.username.trim()
            ? settings.username.trim()
            : "Anonym";
        } catch (e) {
          return "Anonym";
        }
      }

      function sharePlaylist(playlistId) {
        if (!playlistId || !playlists[playlistId]) return;

        const settings = JSON.parse(
          localStorage.getItem("song_lab_settings") || "{}"
        );
        const baseUrl = settings.serverUrl && settings.serverUrl.trim();
        const playlistName = playlists[playlistId].name || "Playlist";
        const sharedBy = getUsernameFromSettings();

        // Build the same URL as for playlist download (baseUrl + playlistQuery)
        if (!baseUrl || !remotePlaylistQuery) {
          console.warn(
            "Missing config for sharing: serverUrl or playlistQuery"
          );
          try {
            const ariaLive = document.getElementById("ariaLive");
            if (ariaLive)
              ariaLive.textContent = "Nelze sdílet: chybí konfigurace serveru.";
          } catch (e) {}
          return;
        }
        const playlistsUrl = appendQueryString(baseUrl, remotePlaylistQuery);
        const urlWithAction = appendQueryString(playlistsUrl, "action=share");

        // Prepare payload in the same format as downloaded entries
        const songKeys = (playlists[playlistId].items || [])
          .map((i) => i && i.songKey)
          .filter(Boolean);
        const payload = {
          playlistId: `${playlistName} (${sharedBy})`,
          name: playlistName,
          sharedBy: sharedBy,
          songs: songKeys,
        };

        console.log("Sharing playlist to", urlWithAction, "with item:", payload);

        fetch(urlWithAction, {
          method: "POST",
          headers: { "Content-Type": "text/plain" },
          body: JSON.stringify(payload),
        }).then(async (res) => {
          if (!res.ok) {
            const text = await res.text().catch(() => "");
            throw new Error(
              "Share HTTP " + res.status + (text ? ": " + text : "")
            );
          }
          // Mark as shared locally on success
          sharedPlaylists[playlistId] = {
            sharedAt: new Date().toISOString(),
            shareId: payload.playlistId,
          };
          saveSharedPlaylists();
          updateShareButton();
          try {
            const ariaLive = document.getElementById("ariaLive");
            if (ariaLive)
              ariaLive.textContent = `Playlist \"${playlistName}\" byl sdílen`;
          } catch (e) {}
          // Refresh remote playlists list
          fetchRemoteConfig();
        });
      }

      function unsharePlaylist(playlistId) {
        if (!playlistId || !sharedPlaylists[playlistId]) return;

        const settings = JSON.parse(
          localStorage.getItem("song_lab_settings") || "{}"
        );
        const baseUrl = settings.serverUrl && settings.serverUrl.trim();
        const playlistName = playlists[playlistId]
          ? playlists[playlistId].name || "Playlist"
          : "Playlist";
        const shareId = sharedPlaylists[playlistId].shareId || playlistName;

        if (!baseUrl || !remotePlaylistQuery) {
          console.warn(
            "Missing config for unsharing: serverUrl or playlistQuery"
          );
          // still remove local state
          delete sharedPlaylists[playlistId];
          saveSharedPlaylists();
          updateShareButton();
          return;
        }
        const playlistsUrl = appendQueryString(baseUrl, remotePlaylistQuery);
        const urlWithAction = appendQueryString(playlistsUrl, "action=unshare");

        const payload = { playlistId: shareId };

        fetch(urlWithAction, {
          method: "POST",
          headers: { "Content-Type": "text/plain" },
          body: JSON.stringify(payload),
        })
          .then(async (res) => {
            if (!res.ok) {
              const text = await res.text().catch(() => "");
              throw new Error(
                "Unshare HTTP " + res.status + (text ? ": " + text : "")
              );
            }
          })
          .catch((err) => {
            console.warn("Unshare request failed:", err);
          })
          .finally(() => {
            // Remove from shared playlists locally regardless
            delete sharedPlaylists[playlistId];
            saveSharedPlaylists();
            updateShareButton();
            console.log("Unshared playlist shareId:", shareId);
            try {
              const ariaLive = document.getElementById("ariaLive");
              if (ariaLive)
                ariaLive.textContent = `Sdílení playlistu "${playlistName}" bylo zrušeno`;
            } catch (e) {}
          });
      }

      function updateShareButton() {
        const shareBtn = document.getElementById("sharePlaylistBtn");
        if (!shareBtn) return;

        const isShared =
          currentPlaylistId && sharedPlaylists[currentPlaylistId];

        if (isShared) {
          shareBtn.classList.add("shared");
          shareBtn.title = "Zrušit sdílení playlistu";
          shareBtn.setAttribute("aria-label", "Zrušit sdílení playlistu");
          // Change icon to "unlink" icon for unshare
          shareBtn.innerHTML = `
               <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                 <path d="M18.84 12.25l1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07a5.006 5.006 0 0 0-7.07-.12l-1.71 1.72" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                 <path d="M5.17 11.75l-1.72 1.71a5.004 5.004 0 0 0 .12 7.07a5.006 5.006 0 0 0 7.07.12l1.71-1.72" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                 <line x1="8" y1="2" x2="16" y2="10" stroke="currentColor" stroke-width="2"/>
                 <line x1="16" y1="14" x2="8" y2="22" stroke="currentColor" stroke-width="2"/>
               </svg>
             `;
        } else {
          shareBtn.classList.remove("shared");
          shareBtn.title = "Sdílet playlist";
          shareBtn.setAttribute("aria-label", "Sdílet playlist");
          // Use standard share icon with connected circles
          shareBtn.innerHTML = `
               <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                 <circle cx="18" cy="5" r="3" stroke="currentColor" stroke-width="2"/>
                 <circle cx="6" cy="12" r="3" stroke="currentColor" stroke-width="2"/>
                 <circle cx="18" cy="19" r="3" stroke="currentColor" stroke-width="2"/>
                 <line x1="8.59" y1="13.51" x2="15.42" y2="17.49" stroke="currentColor" stroke-width="2"/>
                 <line x1="15.41" y1="6.51" x2="8.59" y2="10.49" stroke="currentColor" stroke-width="2"/>
               </svg>
             `;
        }
      }

      function onShareButtonClick() {
        if (!currentPlaylistId) return;

        const isShared = sharedPlaylists[currentPlaylistId];

        if (isShared) {
          unsharePlaylist(currentPlaylistId);
        } else {
          sharePlaylist(currentPlaylistId);
        }

        focusSearch();
      }

      // Global touch event handler to prevent scrolling during drag
      function setupGlobalTouchHandlers() {
        document.addEventListener(
          "touchmove",
          (e) => {
            if (touchDragState.isDragging) {
              e.preventDefault();
            }
          },
          { passive: false }
        );

        document.addEventListener("touchend", (e) => {
          if (touchDragState.isDragging) {
            // Reset any remaining drag state
            const draggedElement = touchDragState.dragElement;
            if (draggedElement) {
              draggedElement.style.transform = "";
              draggedElement.style.zIndex = "";
              draggedElement.classList.remove("dragging");
            }

            // Remove drop hint
            if (touchDragState.dropHint) {
              touchDragState.dropHint.remove();
              touchDragState.dropHint = null;
            }

            // Clear drop indicators
            document
              .querySelectorAll(
                ".playlist-item.drop-before, .playlist-item.drop-after"
              )
              .forEach((el) => {
                el.classList.remove("drop-before", "drop-after");
              });

            touchDragState.isDragging = false;
            touchDragState.dragElement = null;
            touchDragState.dragIndex = -1;
            touchDragState.placeholder = null;
          }
        });
      }

      // --- setup event listeners ---
      function setupEventListeners() {
        const searchInput = document.getElementById("searchInput");
        const clearBtn = document.getElementById("searchClearBtn");
        const titleEl = document.getElementById("playlistTitle");
        const newBtn = document.getElementById("newPlaylistBtn");
        const delBtn = document.getElementById("deletePlaylistBtn");
        const clearPlBtn = document.getElementById("clearPlaylistBtn");
        const ariaLive = document.getElementById("ariaLive");
        const prevBtn = document.getElementById("prevInPlaylist");
        const nextBtn = document.getElementById("nextInPlaylist");
        const prevTopBtn = document.getElementById("prevInPlaylistTop");
        const nextTopBtn = document.getElementById("nextInPlaylistTop");

        // Search input handlers
        searchInput.addEventListener("input", handleSearch);
        searchInput.addEventListener("keydown", handleKeydown);
        clearBtn.addEventListener("click", clearSearch);
        document.addEventListener("click", (ev) => {
          if (!ev.target.closest(".search-container")) hideResults();
        });

        // Preview navigation
        if (prevBtn) prevBtn.addEventListener("click", prevInPlaylist);
        if (nextBtn) nextBtn.addEventListener("click", nextInPlaylist);
        if (prevTopBtn) prevTopBtn.addEventListener("click", prevInPlaylist);
        if (nextTopBtn) nextTopBtn.addEventListener("click", nextInPlaylist);

        // Playlist title editing
        if (titleEl) {
          titleEl.addEventListener("blur", onPlaylistTitleEdit);
          titleEl.addEventListener("focus", () => {
            // Pre-select all text when focusing for editing
            setTimeout(() => {
              if (document.activeElement === titleEl) {
                const range = document.createRange();
                range.selectNodeContents(titleEl);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
              }
            }, 0);
          });
          titleEl.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              titleEl.blur();
            }
          });
        }

        // Playlist selection chevron
        const chevronBtn = document.getElementById("playlistChevron");
        if (chevronBtn) {
          chevronBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const dropdown = document.getElementById("playlistDropdown");
            if (dropdown && dropdown.classList.contains("show")) {
              hidePlaylistDropdown();
            } else {
              showPlaylistDropdown();
            }
          });
        }

        // Hide dropdown when clicking outside
        document.addEventListener("click", (e) => {
          const dropdown = document.getElementById("playlistDropdown");
          if (
            dropdown &&
            !e.target.closest("#playlistTitle") &&
            !e.target.closest("#playlistDropdown") &&
            !e.target.closest("#playlistChevron")
          ) {
            hidePlaylistDropdown();
          }
        });

        // Playlist actions
        newBtn.addEventListener("click", () =>
          createNewPlaylist("Nový playlist")
        );
        delBtn.addEventListener("click", deleteCurrentPlaylist);
        clearPlBtn.addEventListener("click", clearPlaylist);

        const exportBtn = document.getElementById("exportPlaylistBtn");
        if (exportBtn)
          exportBtn.addEventListener("click", exportCurrentPlaylist);

        const shareBtn = document.getElementById("sharePlaylistBtn");
        if (shareBtn) shareBtn.addEventListener("click", onShareButtonClick);

        // focus shortcuts
        document.addEventListener("keydown", (e) => {
          const active = document.activeElement;
          const isTyping =
            active &&
            (active.tagName === "INPUT" ||
              active.tagName === "TEXTAREA" ||
              active.isContentEditable);
          if (isTyping) return;
          if (e.key === "/" && !e.metaKey && !e.ctrlKey) {
            e.preventDefault();
            try {
              searchInput.focus();
              searchInput.select();
            } catch (err) {}
          }
          if (
            e.key &&
            e.key.toLowerCase() === "k" &&
            (e.ctrlKey || e.metaKey)
          ) {
            e.preventDefault();
            try {
              searchInput.focus();
              searchInput.select();
            } catch (err) {}
          }
        });
      }

      function debounce(fn, wait) {
        let t = null;
        return function () {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, arguments), wait);
        };
      }

      // Settings functionality
      function loadSettings() {
        try {
          const settings = JSON.parse(
            localStorage.getItem("song_lab_settings") || "{}"
          );
          const usernameInput = document.getElementById("usernameInput");
          const serverUrlInput = document.getElementById("serverUrlInput");
          const usernameDisplay = document.getElementById("usernameDisplay");

          if (usernameInput && settings.username) {
            usernameInput.value = settings.username;
          }
          if (serverUrlInput && settings.serverUrl) {
            serverUrlInput.value = settings.serverUrl;
          }
          if (usernameDisplay && settings.username) {
            usernameDisplay.textContent = settings.username;
            usernameDisplay.style.display = "block";
          }
        } catch (e) {
          console.error("Failed to load settings", e);
        }
      }

      // Fetch remote config, then fetch shared playlists using playlistQuery
      function fetchRemoteConfig() {
        try {
          const settings = JSON.parse(
            localStorage.getItem("song_lab_settings") || "{}"
          );
          const baseUrl = settings.serverUrl && settings.serverUrl.trim();

          remoteConfigOptions = [];
          remotePlaylistQuery = null;
          remotePlaylists = [];
          remotePlaylistsLoaded = false;
          remotePlaylistsError = null;

          if (!baseUrl) return;

          fetch(baseUrl, { cache: "no-store" })
            .then(async (res) => {
              if (!res.ok) throw new Error("Remote config HTTP " + res.status);
              const json = await res.json();
              remoteConfigOptions = Array.isArray(json) ? json : [];
              const opt = remoteConfigOptions.find(
                (o) =>
                  o &&
                  (o.option === "playlistQuery" || o.option === "playlisQuery")
              );
              if (opt && opt.value) {
                remotePlaylistQuery = String(opt.value);
                const playlistsUrl = appendQueryString(
                  baseUrl,
                  remotePlaylistQuery
                );
                return fetch(playlistsUrl, { cache: "no-store" });
              }
              return null;
            })
            .then(async (res) => {
              if (!res) {
                remotePlaylistsLoaded = true;
                return;
              }
              if (!res.ok) throw new Error("Playlists HTTP " + res.status);
              const arr = await res.json();
              remotePlaylists = normalizeRemotePlaylists(arr);
              remotePlaylistsLoaded = true;
            })
            .catch((err) => {
              console.error("Failed to fetch remote config/playlists", err);
              remotePlaylistsError =
                err && err.message ? err.message : String(err);
              remotePlaylistsLoaded = true;
            });
        } catch (e) {
          console.error("Failed to initiate remote config fetch", e);
        }
      }

      function appendQueryString(baseUrl, queryString) {
        try {
          const u = new URL(baseUrl);
          const extra = new URLSearchParams(queryString);
          extra.forEach((v, k) => u.searchParams.set(k, v));
          return u.toString();
        } catch (e) {
          return baseUrl + (baseUrl.includes("?") ? "&" : "?") + queryString;
        }
      }

      function normalizeRemotePlaylists(arr) {
        if (!Array.isArray(arr)) return [];
        return arr
          .map((entry) => {
            const pid = entry && (entry.playlistId || entry.id || "");
            let payload = entry && entry.value;
            if (payload && typeof payload === "string") {
              try {
                payload = JSON.parse(payload);
              } catch (_) {
                payload = {};
              }
            }
            if (!payload || typeof payload !== "object") payload = {};
            const songs = Array.isArray(payload.songs) ? payload.songs : [];
            const items = songs.map((songKey) => {
              const data = songsData[songKey];
              const title = data ? cleanTitleForDisplay(songKey) : songKey;
              const firstLine = data ? getFirstLine(data) : "";
              return { title, firstLine, songKey };
            });
            return {
              playlistId: pid || payload.playlistId || payload.name || "",
              name: payload.name || pid || "Sdílený playlist",
              sharedBy: payload.sharedBy || "",
              items,
            };
          })
          .filter((p) => p && (p.playlistId || p.name));
      }

      function importRemotePlaylist(rp) {
        const name = (rp && (rp.name || rp.playlistId)) || "Sdílený playlist";
        const newId = createNewPlaylist(name);
        const pl = playlists[newId];
        pl.items = Array.isArray(rp.items) ? rp.items.slice(0, 200) : [];
        savePlaylists();
        currentPlaylistId = newId;
        updatePlaylistTitle();
        renderCurrentPlaylist();
        clearSongPreview();
        updateShareButton();
        try {
          const ariaLive = document.getElementById("ariaLive");
          if (ariaLive)
            ariaLive.textContent = "Stažen sdílený playlist: " + name;
        } catch (e) {}
        focusSearch();
      }

      function saveSettings() {
        try {
          const usernameInput = document.getElementById("usernameInput");
          const serverUrlInput = document.getElementById("serverUrlInput");
          const usernameDisplay = document.getElementById("usernameDisplay");

          const settings = {
            username: usernameInput ? usernameInput.value.trim() : "",
            serverUrl: serverUrlInput ? serverUrlInput.value.trim() : "",
          };

          localStorage.setItem("song_lab_settings", JSON.stringify(settings));

          // Update username display
          if (usernameDisplay) {
            if (settings.username) {
              usernameDisplay.textContent = settings.username;
              usernameDisplay.style.display = "block";
            } else {
              usernameDisplay.style.display = "none";
            }
          }

          closeSettingsModal();

          // Announce save for screen readers
          try {
            const ariaLive = document.getElementById("ariaLive");
            if (ariaLive) ariaLive.textContent = "Nastavení uloženo";
          } catch (e) {}

          // Re-fetch remote config/playlists if server URL changed
          fetchRemoteConfig();
        } catch (e) {
          console.error("Failed to save settings", e);
        }
      }

      function openSettingsModal() {
        const overlay = document.getElementById("settingsOverlay");
        if (overlay) {
          overlay.classList.add("show");
          overlay.setAttribute("aria-hidden", "false");

          // Focus first input
          const usernameInput = document.getElementById("usernameInput");
          if (usernameInput) {
            setTimeout(() => usernameInput.focus(), 100);
          }
        }
      }

      function closeSettingsModal() {
        const overlay = document.getElementById("settingsOverlay");
        if (overlay) {
          overlay.classList.remove("show");
          overlay.setAttribute("aria-hidden", "true");

          // Return focus to settings button
          const settingsBtn = document.getElementById("settingsBtn");
          if (settingsBtn) {
            settingsBtn.focus();
          }
        }
      }

      function setupSettingsEventListeners() {
        const settingsBtn = document.getElementById("settingsBtn");
        const settingsOverlay = document.getElementById("settingsOverlay");
        const settingsForm = document.getElementById("settingsForm");
        const cancelBtn = document.getElementById("cancelSettingsBtn");
        const saveBtn = document.getElementById("saveSettingsBtn");

        // Open settings modal
        if (settingsBtn) {
          settingsBtn.addEventListener("click", (e) => {
            e.preventDefault();
            openSettingsModal();
          });
        }

        // Close modal when clicking overlay background
        if (settingsOverlay) {
          settingsOverlay.addEventListener("click", (e) => {
            if (e.target === settingsOverlay) {
              closeSettingsModal();
            }
          });
        }

        // Cancel button
        if (cancelBtn) {
          cancelBtn.addEventListener("click", (e) => {
            e.preventDefault();
            closeSettingsModal();
          });
        }

        // Save button and form submission
        if (settingsForm) {
          settingsForm.addEventListener("submit", (e) => {
            e.preventDefault();
            saveSettings();
          });
        }

        if (saveBtn) {
          saveBtn.addEventListener("click", (e) => {
            e.preventDefault();
            saveSettings();
          });
        }

        // ESC key to close modal
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            const overlay = document.getElementById("settingsOverlay");
            if (overlay && overlay.classList.contains("show")) {
              e.preventDefault();
              closeSettingsModal();
            }
          }
        });
      }

      // Accessible confirm dialog helper
      function openConfirm(message) {
        return new Promise((resolve) => {
          const dialog = document.getElementById("confirmDialog");
          const msg = document.getElementById("confirmDialogMessage");
          const yes = document.getElementById("confirmYesBtn");
          const no = document.getElementById("confirmNoBtn");
          if (!dialog || !msg || !yes || !no) {
            resolve(window.confirm(message));
            return;
          }
          msg.textContent = message;
          dialog.style.display = "flex";
          dialog.setAttribute("aria-hidden", "false");
          // trap focus simply
          const prevActive = document.activeElement;
          yes.focus();
          function cleanup() {
            dialog.style.display = "none";
            dialog.setAttribute("aria-hidden", "true");
            yes.removeEventListener("click", onYes);
            no.removeEventListener("click", onNo);
            document.removeEventListener("keydown", onKey);
            try {
              prevActive && prevActive.focus();
            } catch (e) {}
          }
          function onYes() {
            cleanup();
            resolve(true);
          }
          function onNo() {
            cleanup();
            resolve(false);
          }
          function onKey(e) {
            if (e.key === "Escape") {
              onNo();
            }
            if (e.key === "Enter") {
              onYes();
            }
          }
          yes.addEventListener("click", onYes);
          no.addEventListener("click", onNo);
          document.addEventListener("keydown", onKey);
        });
      }

      document.addEventListener("DOMContentLoaded", async () => {
        await loadSongsData();
        loadPlaylists();
        setupEventListeners();
        loadSettings();
        // Fetch remote configuration using stored settings.serverUrl
        fetchRemoteConfig();
        setupSettingsEventListeners();
        setupGlobalTouchHandlers();
        // autofocus attempts
        const input = document.getElementById("searchInput");
        if (input) {
          try {
            input.focus();
            setTimeout(() => {
              try {
                input.focus();
                input.select && input.select();
              } catch (e) {}
            }, 50);
          } catch (e) {}
        }
      });
    </script>
  </body>
</html>
